"use strict";

exports.__esModule = true;
exports.default = void 0;

var _Permission = _interopRequireDefault(require("./Permission"));

var _Role = _interopRequireDefault(require("./Role"));

var _Base = _interopRequireDefault(require("./Base"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

class Storage {
  useRBAC(rbac) {
    if (this.rbac) {
      throw new Error('Storage is already in use with another instance of RBAC');
    }

    this.rbac = rbac;
  }
  /**
   * Add permission or role
   * @method Storage#add
   * @param {Base} item Instance of role or permission
   */


  add(item) {
    return _asyncToGenerator(function* () {
      throw new Error('Storage method add is not implemented');
    })();
  }
  /**
   * Remove permission or role
   * @method Storage#remove
   * @param {Base} item Instance of role or permission
   */


  remove(item) {
    return _asyncToGenerator(function* () {
      throw new Error('Storage method remove is not implemented');
    })();
  }
  /**
   * Add (grant) permission or role to hierarchy of actual role
   * @method Storage#grant
   * @param  {Role} role  Instance of role
   * @param  {Base} child Instance of role or permission
   */


  grant(role, child) {
    return _asyncToGenerator(function* () {
      throw new Error('Storage method grant is not implemented');
    })();
  }
  /**
   * Remove (revoke) permission or role from hierarchy of actual role
   * @method Storage#revoke
   * @param  {Role} role  Instance of role
   * @param  {Base} child Instance of role or permission
   */


  revoke(role, child) {
    return _asyncToGenerator(function* () {
      throw new Error('Storage method revoke is not implemented');
    })();
  }
  /**
   * Get instance of permission or role by his name
   * @method Storage#get
   * @param  {String} name Name of role or permission
   * @return {Base}
   */


  get(name) {
    return _asyncToGenerator(function* () {
      throw new Error('Storage method get is not implemented');
    })();
  }
  /**
   * Get all instances of Roles
   * @method Storage#getRoles
   * @return {Role[]}
   */


  getRoles() {
    return _asyncToGenerator(function* () {
      throw new Error('Storage method getRoles is not implemented');
    })();
  }
  /**
   * Get all instances of Permissions
   * @method Storage#getPermissions
   * @return {Permission[]}
   */


  getPermissions() {
    return _asyncToGenerator(function* () {
      throw new Error('Storage method getPermissions is not implemented');
    })();
  }
  /**
   * Get instances of Roles and Permissions assigned to role
   * @method Storage#getGrants
   * @param  {String} role Name of role
   * @return {Base[]}
   */


  getGrants(role) {
    return _asyncToGenerator(function* () {
      throw new Error('Storage method getGrants is not implemented');
    })();
  }
  /**
   * Get instance of role by his name
   * @method Storage#getRole
   * @param  {String} name Name of role
   * @return {Role}
   */


  getRole(name) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const role = yield _this.get(name);

      if (role && role instanceof _Role.default) {
        return role;
      }

      return undefined;
    })();
  }
  /**
   * Get instance of permission by his name
   * @method Storage#getPermission
   * @param  {string} action   Name of action
   * @param  {string} resource Name of resource
   * @return {Permission}           Instance of actual storage
   */


  getPermission(action, resource) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const name = _Permission.default.createName(action, resource, _this2.rbac.options.delimiter);

      const item = yield _this2.get(name);

      if (item && item instanceof _Permission.default) {
        return item;
      }

      return undefined;
    })();
  }
  /**
   * Return true with callback if role or permission exists
   * @method Storage#exists
   * @param  {string} name Name of role or permission
   * @return {boolean}
   */


  exists(name) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      const item = yield _this3.get(name);
      return !!item;
    })();
  }
  /**
   * Return true with callback if role exists
   * @method Storage#existsRole
   * @param  {string} name Name of role
   * @return {boolean}
   */


  existsRole(name) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      const role = yield _this4.getRole(name);
      return !!role;
    })();
  }
  /**
   * Return true with callback if permission exists
   * @method Storage#existsPermission
   * @param  {string} action Name of action
   * @param  {string} resource Name of resource
   * @return {boolean}
   */


  existsPermission(action, resource) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      const permission = yield _this5.getPermission(action, resource);
      return !!permission;
    })();
  }

}

exports.default = Storage;
//# sourceMappingURL=Storage.js.map